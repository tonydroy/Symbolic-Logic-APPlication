package slapp.editor.derivation.DerSystems;

import com.gluonhq.richtextarea.RichTextArea;
import com.gluonhq.richtextarea.model.Document;
import javafx.event.ActionEvent;
import javafx.scene.text.Text;
import javafx.scene.text.TextFlow;
import javafx.util.Pair;
import slapp.editor.decorated_rta.BoxedDRTA;
import slapp.editor.derivation.DerivationCheck;
import slapp.editor.derivation.ViewLine;
import slapp.editor.parser.Language;
import slapp.editor.parser.MatchUtilities;
import slapp.editor.parser.ParseUtilities;
import slapp.editor.parser.TextMessageException;

import java.util.Collections;
import java.util.List;

public class DisjunctionExploit extends DerivationRule {

    public DisjunctionExploit(String name, String rgexTemplate) {
        super(name, rgexTemplate);
        this.premAssp = false;
    }

    public Pair<Boolean, List<Text>> applies(DerivationCheck checker, ViewLine line, String... inputs) {

        BoxedDRTA lineBDRTA = line.getLineContentBoxedDRTA();
        RichTextArea lineRTA = lineBDRTA.getRTA();
        lineRTA.getActionFactory().saveNow().execute(new ActionEvent());
        Document lineDoc = lineRTA.getDocument();


        ViewLine dsjLine;
        Pair<ViewLine, List<Text>> dsjLinePair = checker.getLineFromLabel(inputs[0]);
        if (dsjLinePair.getKey() != null) dsjLine = dsjLinePair.getKey();
        else return new Pair(false, dsjLinePair.getValue());

        BoxedDRTA dsjLineBDRTA = dsjLine.getLineContentBoxedDRTA();
        RichTextArea dsjLineRTA = dsjLineBDRTA.getRTA();
        dsjLineRTA.getActionFactory().saveNow().execute(new ActionEvent());
        Document dsjLineDoc = dsjLineRTA.getDocument();
        if (dsjLineDoc.getText().equals("")) return new Pair(false, Collections.singletonList(ParseUtilities.newRegularText("Justification cannot appeal to the empty line (" + inputs[0] + ").")));


        ViewLine topLine1;
        Pair<ViewLine, List<Text>> topLine1Pair = checker.getLineFromLabel(inputs[1]);
        if (topLine1Pair.getKey() != null) topLine1 = topLine1Pair.getKey();
        else return new Pair(false, topLine1Pair.getValue());

        BoxedDRTA topLine1BDRTA = topLine1.getLineContentBoxedDRTA();
        RichTextArea topLine1RTA = topLine1BDRTA.getRTA();
        topLine1RTA.getActionFactory().saveNow().execute(new ActionEvent());
        Document topLine1Doc = topLine1RTA.getDocument();
        if (topLine1Doc.getText().equals("")) return new Pair(false, Collections.singletonList(ParseUtilities.newRegularText("Justification cannot appeal to the empty line (" + inputs[1] + ").")));


        ViewLine bottomLine1;
        Pair<ViewLine, List<Text>> bottomLine1Pair = checker.getLineFromLabel(inputs[2]);
        if (bottomLine1Pair.getKey() != null) bottomLine1 = bottomLine1Pair.getKey();
        else return new Pair(false, bottomLine1Pair.getValue());

        BoxedDRTA bottomLine1BDRTA = bottomLine1.getLineContentBoxedDRTA();
        RichTextArea bottomLine1RTA = bottomLine1BDRTA.getRTA();
        bottomLine1RTA.getActionFactory().saveNow().execute(new ActionEvent());
        Document bottomLine1Doc = bottomLine1RTA.getDocument();
        if (bottomLine1Doc.getText().equals("")) return new Pair(false, Collections.singletonList(ParseUtilities.newRegularText("Justification cannot appeal to the empty line (" + inputs[2] + ").")));

        ViewLine topLine2;
        Pair<ViewLine, List<Text>> topLine2Pair = checker.getLineFromLabel(inputs[3]);
        if (topLine2Pair.getKey() != null) topLine2 = topLine2Pair.getKey();
        else return new Pair(false, topLine2Pair.getValue());

        BoxedDRTA topLine2BDRTA = topLine2.getLineContentBoxedDRTA();
        RichTextArea topLine2RTA = topLine2BDRTA.getRTA();
        topLine2RTA.getActionFactory().saveNow().execute(new ActionEvent());
        Document topLine2Doc = topLine2RTA.getDocument();
        if (topLine2Doc.getText().equals("")) return new Pair(false, Collections.singletonList(ParseUtilities.newRegularText("Justification cannot appeal to the empty line (" + inputs[3] + ").")));


        ViewLine bottomLine2;
        Pair<ViewLine, List<Text>> bottomLine2Pair = checker.getLineFromLabel(inputs[4]);
        if (bottomLine2Pair.getKey() != null) bottomLine2 = bottomLine2Pair.getKey();
        else return new Pair(false, bottomLine2Pair.getValue());

        BoxedDRTA bottomLine2BDRTA = bottomLine2.getLineContentBoxedDRTA();
        RichTextArea bottomLine2RTA = bottomLine2BDRTA.getRTA();
        bottomLine2RTA.getActionFactory().saveNow().execute(new ActionEvent());
        Document bottomLine2Doc = bottomLine2RTA.getDocument();
        if (bottomLine2Doc.getText().equals("")) return new Pair(false, Collections.singletonList(ParseUtilities.newRegularText("Justification cannot appeal to the empty line (" + inputs[4] + ").")));

        Pair<Boolean, List<Text>> dsjPair = checker.lineIsAccessibleTo(dsjLine, line);
        if (!dsjPair.getKey()) {
            return dsjPair;
        }

        Pair<Boolean, List<Text>> subderivation1Pair = checker.isSubderivation(inputs[1], inputs[2]);
        if (!subderivation1Pair.getKey()) {
            return subderivation1Pair;
        }

        Pair<Boolean, List<Text>> subderivation2Pair = checker.isSubderivation(inputs[3], inputs[4]);
        if (!subderivation2Pair.getKey()) {
            return subderivation2Pair;
        }

        Pair<Boolean, List<Text>> accessibility1Pair = checker.isAccessibleSubderivationFor(line, inputs[1], inputs[2]);
        if (!accessibility1Pair.getKey()) {
            return accessibility1Pair;
        }

        Pair<Boolean, List<Text>> accessibility2Pair = checker.isAccessibleSubderivationFor(line, inputs[3], inputs[4]);
        if (!accessibility2Pair.getKey()) {
            return accessibility2Pair;
        }

        Language objectLanguage = checker.getDerivationRuleset().getObjectLanguage();
        Language metaLanguage = checker.getDerivationRuleset().getMetaLanguage();

        String openBracketString = metaLanguage.getOpenBracket1();
        String closeBracketString = metaLanguage.getCloseBracket1();

        TextFlow topJustificationFlow1 = topLine1.getJustificationFlow();
        TextFlow topJustificationFlow2 = topLine2.getJustificationFlow();
        String justificationString1 = checker.getDerivationExercise().getStringFromJustificationFlow(topJustificationFlow1);
        String justificationString2 = checker.getDerivationExercise().getStringFromJustificationFlow(topJustificationFlow2);


        Document contForm1 = new Document("\u22a5" );
        Document contForm2 = new Document(openBracketString + "\ud835\udcac \u2227 \u223c\ud835\udcac" + closeBracketString);
        Document mainDsjForm = new Document(openBracketString + "\ud835\udcab \u2228 \ud835\udcac" + closeBracketString);
        Document inputFormA = new Document("\ud835\udcab" );
        Document inputFormB = new Document("\ud835\udcac" );
        Document outputForm = new Document("\ud835\udcaa");




        //check exit strategies
        boolean asspOK = true;
        boolean basicMatch = false;
        if ((checker.getDerivationRuleset().getAsspDisjExploitCRule().matches(justificationString1) && checker.getDerivationRuleset().getAsspDisjExploitCRule().matches(justificationString2)) ||
                (checker.getDerivationRuleset().getAsspDisjExploitGRule().matches(justificationString1) && checker.getDerivationRuleset().getAsspDisjExploitGRule().matches(justificationString2))) {

            String topStr1 = checker.getDerivationExercise().getLineLabelsFromJustificationFlow(topJustificationFlow1).get(0);
            String topStr2 = checker.getDerivationExercise().getLineLabelsFromJustificationFlow(topJustificationFlow2).get(0);
            if (topStr1.equals(inputs[0]) && topStr2.equals(inputs[0])) basicMatch = true;
        }


        //check for contradiction

        boolean contradiction = false;
        MatchUtilities.clearFormMatch();
        try {
            Pair<Boolean, Boolean> contMatch1 = MatchUtilities.simpleFormMatch(contForm1, lineDoc, checker.getDerivationRuleset().getObjectLanguage().getNameString(), checker.getDerivationRuleset().getMetaLanguage().getNameString());
            contradiction = true;
        } catch (TextMessageException e) { }

        try {
            Pair<Boolean, Boolean> contMatch2 = MatchUtilities.simpleFormMatch(contForm2, lineDoc, checker.getDerivationRuleset().getObjectLanguage().getNameString(), checker.getDerivationRuleset().getMetaLanguage().getNameString());
            contradiction = true;
        } catch (TextMessageException e) { }


        if (contradiction) {
            DerivationRule rule = checker.getDerivationRuleset().getAsspDisjExploitCRule();
            if (!rule.matches(justificationString1) || !rule.matches(justificationString2) || !basicMatch) {
                asspOK = false;
            }
        }
        else {
            DerivationRule rule = checker.getDerivationRuleset().getAsspDisjExploitGRule();
            if (!rule.matches(justificationString1) || !rule.matches(justificationString2) || !basicMatch) {
                asspOK = false;
            }
        }


        //-----------------------



        //try one way
        MatchUtilities.clearFormMatch();
        boolean resultGood0 = false;
        boolean resultGood1 = false;
        boolean resultGood2 = false;
        boolean resultGood3 = false;
        boolean resultGood4 = false;

        try {
            Pair<Boolean, Boolean> mainDsjMatch = MatchUtilities.simpleFormMatch(mainDsjForm, dsjLineDoc, objectLanguage.getNameString(), metaLanguage.getNameString());
        }
        catch (TextMessageException e) {
            return new Pair(false, Collections.singletonList(ParseUtilities.newRegularText("Line (" + dsjLine.getLineNumberLabel().getText() + ") is not of the right form for application of " + getName() + ".")));
        }

        try {
            Pair<Boolean, Boolean> outputLineMatch = MatchUtilities.simpleFormMatch(outputForm, lineDoc, objectLanguage.getNameString(), metaLanguage.getNameString());
            resultGood0 = true;
        }
        catch (TextMessageException e) { }

        try {
            Pair<Boolean, Boolean> topLine1Match = MatchUtilities.simpleFormMatch(inputFormA, topLine1Doc, objectLanguage.getNameString(), metaLanguage.getNameString());
            resultGood1 = true;
        }
        catch (TextMessageException e) { }

        try {
            Pair<Boolean, Boolean> bottomLine1Match = MatchUtilities.simpleFormMatch(outputForm, bottomLine1Doc, objectLanguage.getNameString(), metaLanguage.getNameString());
            resultGood2 = true;
        } catch (TextMessageException e) { }

        try {
            Pair<Boolean, Boolean> topLine2Match = MatchUtilities.simpleFormMatch(inputFormB, topLine2Doc, objectLanguage.getNameString(), metaLanguage.getNameString());
            resultGood3 = true;
        }
        catch (TextMessageException e) { }

        try {
            Pair<Boolean, Boolean> bottomLine2Match = MatchUtilities.simpleFormMatch(outputForm, bottomLine2Doc, objectLanguage.getNameString(), metaLanguage.getNameString());
            resultGood4= true;
        } catch (TextMessageException e) { }

        if (resultGood0 && resultGood1 && resultGood2 && resultGood3 && resultGood4 && asspOK) {
            return new Pair(true, null);
        }

        if (asspOK) {
            return new Pair(false, Collections.singletonList(ParseUtilities.newRegularText("Line (" + line.getLineNumberLabel().getText() + ") requires a disjunction, with a pair of subderivations, one starting with the left side and going to the goal, and another starting with the right and going to the goal.")));
        }
        else {
            if (contradiction) {
                return new Pair(false, Collections.singletonList(ParseUtilities.newRegularText("To use these subderivations by " + getName() + " the exit strategies should be (\ud835\udc50, " + inputs[0] + getName() + ").")));
            }
            else {
                return new Pair(false, Collections.singletonList(ParseUtilities.newRegularText("To use these subderivations by " + getName() + " the exit strategies should be (\ud835\udc54, " + inputs[0] + getName() + ").")));
            }
        }
    }


}
