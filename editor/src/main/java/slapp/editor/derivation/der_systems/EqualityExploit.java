package slapp.editor.derivation.der_systems;

import com.gluonhq.richtextarea.RichTextArea;
import com.gluonhq.richtextarea.model.Document;
import javafx.event.ActionEvent;
import javafx.scene.text.Text;
import javafx.util.Pair;
import slapp.editor.decorated_rta.BoxedDRTA;
import slapp.editor.derivation.DCheck;
import slapp.editor.derivation.ViewLine;
import slapp.editor.parser.*;
import slapp.editor.parser.grammatical_parts.*;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class EqualityExploit extends DerivationRule {

    public EqualityExploit(String name, String rgexTemplate) {
        super(name, rgexTemplate);
        this.premAssp = false;
    }

    public Pair<Boolean, List<Text>> applies(DCheck checker, ViewLine line, String... inputs) {

        BoxedDRTA lineBDRTA = line.getLineContentBoxedDRTA();
        RichTextArea lineRTA = lineBDRTA.getRTA();
        lineRTA.getActionFactory().saveNow().execute(new ActionEvent());
        Document lineDoc = lineRTA.getDocument();

        ViewLine inputLine1;
        Pair<ViewLine, List<Text>> line1Pair = checker.getLineFromLabel(inputs[0]);
        if (line1Pair.getKey() != null) inputLine1 = line1Pair.getKey();
        else return new Pair(false, line1Pair.getValue());

        BoxedDRTA inputBDRTA1 = inputLine1.getLineContentBoxedDRTA();
        RichTextArea inputRTA1 = inputBDRTA1.getRTA();
        inputRTA1.getActionFactory().saveNow().execute(new ActionEvent());
        Document inputDoc1 = inputRTA1.getDocument();
        if (inputDoc1.getText().equals("")) return new Pair(false, Collections.singletonList(ParseUtilities.newRegularText("Justification cannot appeal to empty line (" + inputs[0] + ").")));


        ViewLine inputLine2;
        Pair<ViewLine, List<Text>> line2Pair = checker.getLineFromLabel(inputs[1]);
        if (line2Pair.getKey() != null) inputLine2 = line2Pair.getKey();
        else return new Pair(false, line2Pair.getValue());

        BoxedDRTA inputBDRTA2 = inputLine2.getLineContentBoxedDRTA();
        RichTextArea inputRTA2 = inputBDRTA2.getRTA();
        inputRTA2.getActionFactory().saveNow().execute(new ActionEvent());
        Document inputDoc2 = inputRTA2.getDocument();
        if (inputDoc2.getText().equals("")) return new Pair(false, Collections.singletonList(ParseUtilities.newRegularText("Justification cannot appeal to the empty line (" + inputs[1] + ").")));


        Pair<Boolean, List<Text>> accessibilityPair1 = checker.lineIsAccessibleTo(inputLine1, line);
        if (!accessibilityPair1.getKey()) {
            return accessibilityPair1;
        }

        Pair<Boolean, List<Text>> accessibilityPair2 = checker.lineIsAccessibleTo(inputLine2, line);
        if (!accessibilityPair2.getKey()) {
            return accessibilityPair2;
        }

        Language objectLanguage = checker.getDerivationRuleset().getObjectLanguage();
        Language metaLanguage = checker.getDerivationRuleset().getMetaLanguage();

        String openBracketString = metaLanguage.getOpenBracket1();
        String closeBracketString = metaLanguage.getCloseBracket1();
        String slashDividerString = metaLanguage.getSlashDivider();
//        String commaDividerString = metaLanguage.getCommaDivider();

        Document inputForm1 = new Document("\ud835\udcab" );
        Document inputForm2a = new Document( openBracketString + "\ud835\udcc8 \ue8ac \ud835\udcc9" + closeBracketString );
        Document inputForm2b = new Document( openBracketString + "\ud835\udcc9 \ue8ac \ud835\udcc8" + closeBracketString );
        Document inputForm2c = new Document("\ue8ac\ud835\udcc8\ud835\udcc9");
        Document inputForm2d = new Document("\ue8ac\ud835\udcc9\ud835\udcc8");
        Document outputForm = new Document("\ud835\udcab\u2039 \ud835\udcc8" + slashDividerString + "\ud835\udcc9 \u203a");

        Term term1 = null;
        Term term2 = null;
        Formula originalFormula = null;

        List<Text> message1 = null;
        List<Text> message2 = null;
        List<Text> message3 = null;
        List<Text> message4 = null;


        //catch reverse (but allow equality first if both inputs are equalities)
        MatchUtilities.clearFormMatch();
        boolean reverse = false;
        boolean reverseA = false;
        boolean reverseB = false;
        try {
            Pair<Boolean, Boolean> reverseMatch1 = MatchUtilities.simpleFormMatch(inputForm2a, inputDoc1, objectLanguage.getNameString(), metaLanguage.getNameString());
            reverse = true;
        }
        catch (TextMessageException e) {}
        if (reverse) {
            MatchUtilities.clearFormMatch();
            try {
                Pair<Boolean, Boolean> reverseMatchA = MatchUtilities.simpleFormMatch(inputForm2a, inputDoc2, objectLanguage.getNameString(), metaLanguage.getNameString());
                reverseA = true;
            }
            catch (TextMessageException e) {}
            MatchUtilities.clearFormMatch();
            try {
                Pair<Boolean, Boolean> reverseMatchB = MatchUtilities.simpleFormMatch(inputForm2c, inputDoc2, objectLanguage.getNameString(), metaLanguage.getNameString());
                reverseB = true;
            }
            catch (TextMessageException e) {}

            if (!reverseA && !reverseB) {
                return new Pair(false, Collections.singletonList(ParseUtilities.newRegularText(("Lines (" + inputLine1.getLineNumberLabel().getText() + ") and (" + inputLine2.getLineNumberLabel().getText() +
                        ") are not of the right form to result in (" + line.getLineNumberLabel().getText() + ") by " + getName() + " (check citation order)."))));
            }
        }

        MatchUtilities.clearFormMatch();
        reverse = false;
        reverseA = false;
        reverseB = false;
        try {
            Pair<Boolean, Boolean> reverseMatch = MatchUtilities.simpleFormMatch(inputForm2c, inputDoc1, objectLanguage.getNameString(), metaLanguage.getNameString());
            reverse = true;
        }
        catch (TextMessageException e) {}
        if (reverse) {
            MatchUtilities.clearFormMatch();
            try {
                Pair<Boolean, Boolean> reverseMatchA = MatchUtilities.simpleFormMatch(inputForm2a, inputDoc2, objectLanguage.getNameString(), metaLanguage.getNameString());
                reverseA = true;
            }
            catch (TextMessageException e) {}
            MatchUtilities.clearFormMatch();
            try {
                Pair<Boolean, Boolean> reverseMatchB = MatchUtilities.simpleFormMatch(inputForm2c, inputDoc2, objectLanguage.getNameString(), metaLanguage.getNameString());
                reverseB = true;
            }
            catch (TextMessageException e) {}

            if (!reverseA && !reverseB) {
                return new Pair(false, Collections.singletonList(ParseUtilities.newRegularText(("Lines (" + inputLine1.getLineNumberLabel().getText() + ") and (" + inputLine2.getLineNumberLabel().getText() +
                        ") are not of the right form to result in (" + line.getLineNumberLabel().getText() + ") by " + getName() + " (check citation order)."))));
            }
        }




        //try correct

        //A
        MatchUtilities.clearFormMatch();
        boolean resultGood1 = false;
        boolean resultGood2 = false;
        boolean resultGood3 = false;

        boolean infix = false;
        boolean prefix = false;

        //infix equality
        try {
            Pair<Boolean, Boolean> inputMatch2a = MatchUtilities.simpleFormMatch(inputForm2a, inputDoc2, objectLanguage.getNameString(), metaLanguage.getNameString());
            infix = true;
        }
        catch (TextMessageException e) {}

        if (infix) {
            try {
                Pair<Boolean, Boolean> inputMatch2a = MatchUtilities.simpleFormMatch(inputForm2a, inputDoc2, objectLanguage.getNameString(), metaLanguage.getNameString());
                resultGood2 = inputMatch2a.getKey();
            } catch (TextMessageException e) {
            }
            try {
                Pair<Boolean, Boolean> inputMatch1 = MatchUtilities.simpleFormMatch(inputForm1, inputDoc1, objectLanguage.getNameString(), metaLanguage.getNameString());
                resultGood1 = inputMatch1.getKey();
            } catch (TextMessageException e) {
            }

            try {
                Pair<Boolean, Boolean> outputMatch = MatchUtilities.simpleFormMatch(outputForm, lineDoc, objectLanguage.getNameString(), metaLanguage.getNameString());
                resultGood3 = outputMatch.getKey();
            } catch (TextMessageException e) {
                message1 = e.getMessageList();

                //           return new Pair(false, e.getMessageList());
            }


            if (resultGood1 && resultGood2 && resultGood3) return new Pair(true, null);

            //B
            MatchUtilities.clearFormMatch();
            resultGood1 = false;
            resultGood2 = false;
            resultGood3 = false;

            try {
                Pair<Boolean, Boolean> inputMatch2b = MatchUtilities.simpleFormMatch(inputForm2b, inputDoc2, objectLanguage.getNameString(), metaLanguage.getNameString());
                resultGood2 = inputMatch2b.getKey();
            } catch (TextMessageException e) {
            }
            try {
                Pair<Boolean, Boolean> inputMatch1 = MatchUtilities.simpleFormMatch(inputForm1, inputDoc1, objectLanguage.getNameString(), metaLanguage.getNameString());
                resultGood1 = inputMatch1.getKey();
            } catch (TextMessageException e) {
            }

            try {
                Pair<Boolean, Boolean> outputMatch = MatchUtilities.simpleFormMatch(outputForm, lineDoc, objectLanguage.getNameString(), metaLanguage.getNameString());
                resultGood3 = outputMatch.getKey();
            } catch (TextMessageException e) {
                message2 = e.getMessageList();
                //       return new Pair(false, e.getMessageList());
            }

            if (resultGood1 && resultGood2 && resultGood3) return new Pair(true, null);
        }


        //prefix
        try {
            Pair<Boolean, Boolean> inputMatch2c = MatchUtilities.simpleFormMatch(inputForm2c, inputDoc2, objectLanguage.getNameString(), metaLanguage.getNameString());
            prefix = true;
        }
        catch (TextMessageException e) {}

        if (prefix) {

            //C
            MatchUtilities.clearFormMatch();
            resultGood1 = false;
            resultGood2 = false;
            resultGood3 = false;

            try {
                Pair<Boolean, Boolean> inputMatch2c = MatchUtilities.simpleFormMatch(inputForm2c, inputDoc2, objectLanguage.getNameString(), metaLanguage.getNameString());
                resultGood2 = inputMatch2c.getKey();
            } catch (TextMessageException e) {
            }
            try {
                Pair<Boolean, Boolean> inputMatch1 = MatchUtilities.simpleFormMatch(inputForm1, inputDoc1, objectLanguage.getNameString(), metaLanguage.getNameString());
                resultGood1 = inputMatch1.getKey();
            } catch (TextMessageException e) {
            }

            try {
                Pair<Boolean, Boolean> outputMatch = MatchUtilities.simpleFormMatch(outputForm, lineDoc, objectLanguage.getNameString(), metaLanguage.getNameString());
                resultGood3 = outputMatch.getKey();
            } catch (TextMessageException e) {
                message3 = e.getMessageList();
                //         return new Pair(false, e.getMessageList());
            }

            if (resultGood1 && resultGood2 && resultGood3) return new Pair(true, null);

            //D
            MatchUtilities.clearFormMatch();
            resultGood1 = false;
            resultGood2 = false;
            resultGood3 = false;

            try {
                Pair<Boolean, Boolean> inputMatch2d = MatchUtilities.simpleFormMatch(inputForm2d, inputDoc2, objectLanguage.getNameString(), metaLanguage.getNameString());
                resultGood2 = inputMatch2d.getKey();
            } catch (TextMessageException e) {
            }

            try {
                Pair<Boolean, Boolean> inputMatch1 = MatchUtilities.simpleFormMatch(inputForm1, inputDoc1, objectLanguage.getNameString(), metaLanguage.getNameString());
                resultGood1 = inputMatch1.getKey();
            } catch (TextMessageException e) {
            }

            try {
                Pair<Boolean, Boolean> outputMatch = MatchUtilities.simpleFormMatch(outputForm, lineDoc, objectLanguage.getNameString(), metaLanguage.getNameString());
                resultGood3 = outputMatch.getKey();
            } catch (TextMessageException e) {
                message4 = e.getMessageList();
                //           return new Pair(false, e.getMessageList());
            }

            if (resultGood1 && resultGood2 && resultGood3) return new Pair(true, null);
        }


        List<Text> bigList = new ArrayList<>();
       if (message1 != null) {
   //        bigList.addAll(message1);
            return new Pair(false, message1);
        }
        if (message2 != null) {
    //        bigList.addAll(message2);
            return new Pair(false, message2);
        }
        if (message3 != null) {
    //        bigList.addAll(message3);
            return new Pair(false, message3);
        }
        if (message4 != null) {
  //          bigList.addAll(message4);
            return new Pair(false, message4);
        }

// new Pair(false, bigList);

        return new Pair(false, Collections.singletonList(ParseUtilities.newRegularText("Lines (" + inputs[0] + ") and (" + inputs[1] + " are not of the right form to result in (" + line.getLineNumberLabel().getText() + ") by " + getName() + ".")));
    }

}
